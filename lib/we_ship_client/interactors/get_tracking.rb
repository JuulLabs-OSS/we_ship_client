# frozen_string_literal: true

require 'we_ship_client/client'
require 'we_ship_client/exceptions'
require 'we_ship_client/entities'
require 'we_ship_client/transforms/tracking_item'

module WeShipClient
  module Interactors
    # Class to interact with the /track API endpoint.
    class GetTracking
      ERRONEOUS_EXCEPTION_MSGS = [
        'RQA Mapping',
        'OQA Mapping',
        'SML Mapping',
        'Out for Delivery'
      ].freeze

      # @param auth_token [String] A token generated by TokenClient
      # @param track_request [Entities::TrackRequest] The request payload
      # @param timeout [Integer,nil] The request timeout
      def initialize(auth_token:, track_request:, timeout: nil)
        @auth_token = auth_token
        @request = track_request
        @timeout = timeout
      end

      # Get the tracking response.
      #
      # @raise [Exceptions::AuthenticationError] If the status code is 401
      # @raise [Exceptions::ServerError] If the response is blank
      # @return [Entities::Responses::TrackResponse] The tracking response
      def call
        response = client.http_client.post(
          "#{client.base_url}/track",
          data: request.to_hash,
          headers: { Authorization: "JWT #{auth_token}" }
        )
        handle_exception(response) unless response.status == 200
        json_response = JSON.parse(response.body, symbolize_names: true)
        handle_exception(response) if json_response[:results].nil?
        filter_results(json_response)
        modified_response(response_class.new(json_response))
      end

      private

      attr_accessor :auth_token, :request, :timeout

      def handle_exception(response)
        WeShipClient.logger.info(
          "[WeShipClient::Interactors::GetTracking] [EXCEPTION] #{response}"
        )

        http_errors = {
          401 => WeShipClient::Exceptions::AuthenticationError
        }

        raise http_errors[response.status], response.body if http_errors.key?(response.status)

        raise WeShipClient::Exceptions::ServerError, response.body
      end

      def response_class
        WeShipClient::Entities::Responses::TrackResponse
      end

      def client
        @client ||= WeShipClient::Client.new(timeout: timeout)
      end

      def filter_results(response) # rubocop:disable Metrics/CyclomaticComplexity, Metrics/PerceivedComplexity
        # filters out tracking items with empty message
        # filters out tracking items with empty tracking_item_date and tracking_item_id
        response[:results].each do |track_order|
          next unless track_order[:tracking_items]

          track_order[:tracking_items] = track_order[:tracking_items].select do |item|
            valid_tracking_item?(item)
          end
        end
      end

      def valid_tracking_item?(item)
        # either date or id must be present
        (item[:tracking_item_date].present? || item[:tracking_item_id].present?) &&
          # message must be present
          item[:message].present? &&
          # does not have a erroneous exception message
          !(item[:status_type] == 'X' && erroneous_exception_msg?(item[:message]))
      end

      def erroneous_exception_msg?(item_message)
        ERRONEOUS_EXCEPTION_MSGS.any? do |msg|
          item_message.downcase.start_with?(msg.downcase)
        end
      end

      def modified_response(response)
        response.results.each do |track_order|
          track_order&.tracking_items&.map do |item|
            next if item.tracking_item_date.nil? && item.tracking_item_id.nil?

            tracking_item_transform_class.new.call(
              tracking_item: item,
              state: track_order.state
            )
          end
        end

        response
      end

      def tracking_item_transform_class
        WeShipClient::Transforms::TrackingItem
      end
    end
  end
end
